#! /usr/bin/env python3

import asyncio
import re

from mirai import (At, Friend, Group, Image, Member, MessageChain, Mirai,
                   Plain, XmlMessage)

import Features

authKey = "MeuPasswd"
qq = 1291517893

mirai = Mirai(f"mirai://127.0.0.1:8080/?authKey={authKey}&qq={qq}", websocket=True)
#status = True                                      #作为脚本开关的判断
#
#@mirai.onStage("around")                           #脚本启动或关闭时给我发消息
#async def greet(mirai: Mirai):
#
#    global status                                  #不知道有没有不用全局变量的办法
#
#    if status == True:
#        messages = "ScriptUP!"
#    elif status == False:
#        messages = "ScriptDown!"
#
#    await mirai.sendFriendMessage(
#            2543823619,
#            [
#                Plain(text=f"{messages}")
#                ]
#            )
#    status = False

#@mirai.subroutine
#async def subroutine0(mirai: Mirai):                #怎么拿message
#    group = [1091328046, 830229301]
#    messages = ['SubroutineON!\n既然不给MessageChain\n那要协处理有何用\n屑!',
#            '另:\n因为找不到合适的脏话词库\n故脏话检测改为敏感词检测(脏话也包括在内)\n找到的词库会做简单修改\n抽象艺术和拼音文化后续补全',
#            '被检测为Ture者会被撤回消息\n并记黑名单,做禁言处理\n过于严重的可能会被踢群或举报']
#
#    await mirai.sendGroupMessage(
#            group[0],
#            [
#                Plain(text=messages[0])
#                ]
#            )

@mirai.receiver("GroupMessage")
async def event_gm(mirai: Mirai, message: MessageChain, group: Group, member: Member):

    messages = message.toString()                   #留做刷屏和脏话的检测
    timestamp = message.__root__[0].time            #每条消息的时间
    membernames = member.memberName
    memberid = member.id                            #发送消息的人

    command = Features.Clear(messages)              #清洗文本,提取指令

#    Features.Analysis(timestamp, membernames, memberid, messages)
                                                    #文本分析:刷屏、脏话、复读机

#    global mesarr
#    if len(mesarr) <= 3:
#        mesarr.append(messages)
#        print(mesarr)
#    if len(mesarr) == 3:
#        if mesarr[2] == mesarr[1]:
#            await mirai.sendGroupMessage(
#                    group.id,
#                    [
#                        Plain(text='匹配')
#                        ]
#                    )
#        mesarr.pop(0)

    switch = {                                      #switch/case
            'text' : Plain,                         #消息组件复用
            'image' : Image.fromFileSystem,         #消息组件复用
            'xml' : XmlMessage,                     #消息组件复用
            ':网抑云' : Features.Cloudmusic,
            ':image' : Features.Image,
            ':rss' : Features.RSS,
            ':zuan' : Features.Zuan,
            ':help' : Features.Help,
            'analysis': Features.Analysis
        }

    async def sendmessage(i):

        try:
            if i == 'analysis':
                try:
                    getmessages, infotype = switch[i](timestamp, membernames, memberid, messages)
                except TypeError:
                    return
            else:
                getmessages, infotype = switch[i]()
        except KeyError:                            #需要参数或者匹配的
            if re.match('^:ping', i):
                getmessages, infotype = Features.Ping(i)
            else:
                return

        await mirai.sendGroupMessage(
                group.id,
                [
                    At(target=memberid),
                    switch[infotype](getmessages)
                    ]
                )

    for i in command:                               #经过清洗提取的指令会逐一运行
        await sendmessage(i)

if __name__ == "__main__":
    mirai.run()
